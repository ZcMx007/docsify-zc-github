# JUC

记录java.util.concurrent包的学习

## 正规唤醒

另一个线程调用此对象的notify()和notifyAll()方法唤醒依据此对象休眠的线程(JVM操作原理就是在线程休眠时在线程所处的对象的对象头信息中记录休眠的线程地址，之后会对执行该对象方法的每条线程都与休眠的线程地址列表作较，相同则不允许操作；调用notify()和notifyAll()方法后，就是随机清除该对象休眠列表中的休眠线程地址以及部清除休眠该对象休眠列表中的休眠线程地址)。有点类似于早上闹铃响了，喊你起床，你被唤醒了的场景。

## 虚假唤醒

所谓的虚假唤醒指的是一个等待的线程存在以下的两种唤醒方式：
1、该线程被其他线程中断，这个时候也会清除该对象休眠列表中的此线程地址。有点类似于早上你在睡觉呢，结果旁边玩游戏的兄弟鬼使神差的对着睡觉的你来了一句:睡什么睡，下一把一起呀！然后你就中断了睡觉的状态，被吵醒了。
2、该线程的休眠时间一般会有一个上限值，即保存在对象休眠列表中的休眠线程地址是有时效性的，会定期清除，如果由timeout毫秒加nanos纳秒参数指定的超时时间已过。那么该线程会因为超时而被通知唤醒。有点类似于今天是周末，你可以好好的睡个懒觉，晚上嚷嚷着谁也别吵我，我要睡到死，结果证明，你就算再能睡，一般也就中午这样子就起床了，而且你睡得时间越长，脑袋反而越昏沉，这是因为你过了大脑休息的超时时间了。

正如jdk官方文档中所说的，线程程序是很有可能出现虚假唤醒的情况的，为了保证这种情况的发生应该使得wait()方法始终在循环中判定使用。

```java
 synchronized (obj) {
         while (<condition does not hold>)
             obj.wait(timeout, nanos);
         ... // Perform action appropriate to condition
     } 
```
