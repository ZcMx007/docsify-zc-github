# MYSQL 事务

## @Transactional 注解

spring中有一个极其重要的事务注解，那就是@Transactional，当方法上加了@Transactional注解，这个注解把当前方法中的作为一个事物，只有当方法都完成时，才会进行提交操作。

因此要想实时调用mapper的方法进行修改数据库，可以在mapper方法上加注解，开启新的事务，也就是
@Transactional(propagation= Propagation.REQUIRES_NEW) 表示在原有事务的基础上拓展新的事务（propagation：扩展，培养，传播）

同样有一点需要注意的是如果方法体中预先对可能出错的代码进行了try{}catch{}包裹处理，则一旦try执行的方法体中出错，由于没有抛出异常，因此无法被开启的事务捕获，自然也就无法进行回滚处理，此时如果需要回滚事务，则可以通过：
TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
手动回滚处理。

### 7种传播机制

> 参考[链接](https://blog.csdn.net/totally123/article/details/52301604)

在@Transactional注解中，可以propagation属性用来配置事务传播，支持7种不同的传播机制：

1. **REQUIRED**：业务方法需要在一个事务中运行，如果方法运行时，已处在一个事务中，那么就加入该事务，否则自己创建一个新的事务。这是spring默认的传播行为。
2. **NOT_SUPPORTED**：声明方法不需要事务。如果方法没有关联到一个事务，容器不会为他开启事务，如果方法在一个事务中被调用，该事务会被挂起，调用结束后，原先的事务会恢复执行。
3. **REQUIRESNEW**：不管是否存在事务，该方法总会为自己发起一个新的事务。如果方法已经运行在一个事务中，则原有事务挂起，新的事务被创建。
4. **MANDATORY**：该方法只能在一个已经存在的事务中执行，业务方法不能发起自己的事务。如果在没有事务的环境下被调用，容器抛出例外。
5. **SUPPORTS**：该方法在某个事务范围内被调用，则方法成为该事务的一部分。如果方法在该事务范围外被调用，该方法就在没有事务的环境下执行。
6. **NEVER**：该方法绝对不能在事务范围内执行。如果在就抛异常。只有该方法没有关联到任何事务，才正常执行。
7. **NESTED**：如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager事务管理器起效。
