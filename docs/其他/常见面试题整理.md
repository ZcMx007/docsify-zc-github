# 常见面试题整理

## 1、什么是TCP的三次握手，为什么不是两次或者四次？

TCP之所以需要三次握手是为了确认双端的收发能力是否正常。第一次握手client向server说明client的发送能力是正常的，第二次握手server向client端表明其收发能力都很正常，第三次握手client向server端说明client的接收能力也是正常的。此时client发送给server的消息就能被正常接收处理了。如果是两次握手的的话，则不能保证client端的接收能力是正常的，而一旦发生这种情况，仅仅两次握手会导致server端一直维持着这种无用的连接从而占用资源。如果是4次握手的话，则完全没有必要，反而徒增资源损耗。

## 2、TCP只需要三次握手即可建立连接，可为什么需要四次挥手才能断开连接？

第一次挥手由client向server端挥手，此时client会关闭自身的发送功能；服务端接收到该挥手消息后，由于可能还有未传输完的client信息在发送队列中，因此server向client挥第二次手，表示你要断开连接的请求我已经收到了，此时我已经关闭了我的接收功能，在我发送给你的消息完成发送后，我会再发消息给你确认，你此时只需要等着即可；server发送完了消息，然后向client发送了一条完成发送的确认消息后关闭了自身的发送能力，这是第三次挥手；4、client接收到server发送完成的确认消息，最后client关闭了自身的接收能力。

## 3、事务的四大隔离级别，七大传播特性

事务的ACID原则：原子性、一致性、隔离性、持久性

在并发下可能会出现以下3种问题：脏读（A读取时B回滚）、不可重复读（修改数据）、幻读（新增数据）,由此出现了四大隔离级别：1、**读-未提交**，这种隔离级别无法解决以上任意3种问题；2、读-未提交/不可重复读，此种隔离级别可以保证不会出现脏读，但不可重复读以及幻读无法解决；3、**可重复读**，除了脏读，都可以解决。4、**串行化**，都可以解决。随着隔离级别的增大，对于并发的效率而言是有很大影响的。例如**读-未提交/不可重复读**，将会在事务处理时使用行锁保证数据不会被脏读；**可重复读**情况下，如果检索条件存在索引则会使用next-key锁（范围锁，周边几行），如果检索条件的索引存在唯一性，则还会降级为行锁；但是在隔离级别是**串行化**时，就会在事务操作时锁住整张表避免幻读。

事务的七大传播特性：

PROPAGATION_REQUIRED
支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。

PROPAGATION_SUPPORTS
支持当前事务，如果当前没有事务，就以非事务方式执行。

PROPAGATION_MANDATORY
支持当前事务，如果当前没有事务，就抛出异常。

PROPAGATION_REQUIRES_NEW
新建事务，如果当前存在事务，把当前事务挂起。

PROPAGATION_NOT_SUPPORTED
以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。

PROPAGATION_NEVER
以非事务方式执行，如果当前存在事务，则抛出异常。

PROPAGATION_NESTED
如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则新建一个事务

