# 常见面试题整理

- 1、什么是TCP的三次握手，为什么不是两次或者四次？

TCP之所以需要三次握手是为了确认双端的收发能力是否正常。第一次握手client向server说明client的发送能力是正常的，第二次握手server向client端表明其收发能力都很正常，第三次握手client向server端说明client的接收能力也是正常的。此时client发送给server的消息就能被正常接收处理了。如果是两次握手的的话，则不能保证client端的接收能力是正常的，而一旦发生这种情况，仅仅两次握手会导致server端一直维持着这种无用的连接从而占用资源。如果是4次握手的话，则完全没有必要，反而徒增资源损耗。

- 2、TCP只需要三次握手即可建立连接，可为什么需要四次挥手才能断开连接？

第一次挥手由client向server端挥手，此时client会关闭自身的发送功能；服务端接收到该挥手消息后，由于可能还有未传输完的client信息在发送队列中，因此server向client挥第二次手，表示你要断开连接的请求我已经收到了，此时我已经关闭了我的接收功能，在我发送给你的消息完成发送后，我会再发消息给你确认，你此时只需要等着即可；server发送完了消息，然后向client发送了一条完成发送的确认消息后关闭了自身的发送能力，这是第三次挥手；4、client接收到server发送完成的确认消息，最后client关闭了自身的接收能力。

- 3、事务的四大隔离级别，七大传播特性

事务的ACID原则：原子性、一致性、隔离性、持久性

在并发下可能会出现以下3种问题：脏读（A读取时B回滚）、不可重复读（修改数据）、幻读（新增数据）,由此出现了四大隔离级别：1、**读-未提交**，这种隔离级别无法解决以上任意3种问题；2、**读-已提交/不可重复读**，此种隔离级别可以保证不会出现脏读，但不可重复读以及幻读无法解决；3、**可重复读**，除了脏读，都可以解决。4、**串行化**，都可以解决。随着隔离级别的增大，对于并发的效率而言是有很大影响的。例如**读-未提交/不可重复读**，将会在事务处理时使用行锁保证数据不会被脏读；**可重复读**情况下，如果检索条件存在索引则会使用next-key锁（范围锁，周边几行），如果检索条件的索引存在唯一性，则还会降级为行锁；但是在隔离级别是**串行化**时，就会在事务操作时锁住整张表避免幻读。

事务的七大传播特性：

PROPAGATION_REQUIRED
支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。

PROPAGATION_SUPPORTS
支持当前事务，如果当前没有事务，就以非事务方式执行。

PROPAGATION_MANDATORY
支持当前事务，如果当前没有事务，就抛出异常。

PROPAGATION_REQUIRES_NEW
新建事务，如果当前存在事务，把当前事务挂起。

PROPAGATION_NOT_SUPPORTED
以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。

PROPAGATION_NEVER
以非事务方式执行，如果当前存在事务，则抛出异常。

PROPAGATION_NESTED
如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则新建一个事务

- 4、项目中用到的技术栈介绍一下
- 5、做的自认为比较满意的点讲一讲？
- 6、如果这个方案让你重新设计，你怎么做？
- 7、Java集合类都有哪些？
- 8、set和list的区别？set的底层原理？
- 9、HashMap为什么这么快？HashMap的key可以是null么？
- 10、如何防止反射破坏单例？
- 11、ArrayList 和 LinkedList 区别？
- 12、HashMap 实现数据结构和扩容过程？
- 13、ArrayList 和 LinkedList 区别？ 你平常怎么选择？
- 14、异常类都有哪些？Exception 和 Error什么区别？
- 15、Synchronized 原理，锁膨胀过程 ？
- 16、Synchronized 和 reentrantlock 区别？
- 17、线程池原理是怎样的？
- 18、分布式事务一致性怎么实现？
- 19、消息乱序遇到过吗？ 怎么解决的？
- 20、ThreadLocal 用过吗？实现机制？
- 21、wait、sleep区别？
- 22、反射用过吗？什么原理？
- 23、动态代理了解吗？ cglib什么区别
- 24、单例模式了解吗？ 实现一个线程安全的单例模式？
- 25、无界队列和有界队列？
- 26、AQS 知道吗？
- 27、volatile了解吗？
- 28、实现一个生产者消费者例子
- 29、Java内存模型清楚吗？
- 30、遇到过线上性能问题吗？ 怎么排查的？
- 31、网络问题遇到过吗？TIME_WAIT和CLOSE_WAIT的区别
- 32、三次握手讲一讲
- 33、CountDownLatch、Seamphone、CyclicBarrier 都了解吗？
- 34、private、protected、public、关键字你平常怎么用的？
- 35、Java是值传递还是引用传递，写一段对象拷贝的代码
- 36、内存回收机制了解吗？
- 37、新生代和老生代区别？
- 38、垃圾回收器有哪几种? 你们生产环境用的哪种或哪几种？
- 39、Java线程和操作系统线程什么关系？
- 40、线程有几种状态，线程生命周期讲讲
- 41、MySQL 索引使用什么数据结构？为什么用 B+做索引？
- 42、什么是最左匹配原则？
- 43、在建表的时候如何设计所以的？有没有做过索引优化 ？
- 44、分库分表做了吗？ 怎么实现的？
- 45、MySQL 主从同步怎么做的？binlog清楚吗？
- 46、有没有做分库分表？怎么设计的？
- 47、用userId做的分库分表，现在需要用电话号码查询怎么办？
- 48、你们用的什么日志框架，log4j 和logback ？和slf4j什么区别？
- 49、redis 的String 是怎么实现的？ 为什么不直接用c的？
- 50、写快速排序 & 冒泡排序？
- 51、redis 是单线程的吗？ 为什么这么快？
- 52、redis 中有哪几种数据结构？分别代表什么
- 53、类加载机制了解吗？
- 54、什么是双亲委派模式
- 55、concurrenthashmap 什么原理？
- 56、Spring AOP与IOC的实现原理
- 57、Spring的BeanFactory和FactoryBean的区别
- 58、讲讲Spring中一个Bean的加载流程?
- 59、Spring的事务的隔离级别？
- 60、Autowired注解的原理？
- 61、用的什么rpc框架
- 62、幂等了解吗？ 你们系统怎么做幂等的
- 63、限流、熔断有了解吗？如何实现的
- 64、消息中间件如何解决消息丢失、消息乱序问题？
- 65、分布式事务保证一致性？
- 66、分布式锁的实现？
- 67、实现一个分布式自增id？
- 68、海量url怎么去重？
- 69、Redis有没有做持久化，怎么做的？
- 70、工作中用到了那些设计模式？
- 71、什么是一致性hash？
- 72、项目中用过什么设计模式？清楚模板方法、策略模式、责任链模式吗？
- 73、MySQL InnoDB存储的文件结构
- 74、讲讲乐观锁和悲观锁
- 75、cpu 100% 遇到过吗？ 怎么解决的
- 76、更新数据机制？ 先更新缓存还是DB？
- 77、缓存穿透、雪崩有了解吗
- 78、设计一个抢红包的程序?
- 79、Dp背包问题？
- 80、Minor GC 与 Full GC 分别在什么时候发生？
- 81、Java 类加载过程?
- 82、谈谈对Spring IOC和DI的理解？
- 83、你常用的git 命令？
- 84、线程调用start 和 run 什么区别？ 会有什么效果
- 85、中序遍历二叉树
- 86、之前项目遇到过什么挑战？
- 87、项目中你认为做的最有价值的功能？
- 88、父类和子类有同一个属性，实例化子类时是否会包含父类的属性？
- 89、有没有出现过Full Gc等问题？ 你是怎么排查的？
- 90、一般是怎么判断SQL 索引设置是否合理的？
- 91、什么是不可变对象？String 类为什么设计成不可变的？
- 92、抽象类和接口什么区别？你在做接口和类设计时如何选择？
- 93、HashMap的key 类型有什么要求？
- 94、写一个深度优先算法？
- 95、什么是用户空间和内核空间？有什么区别？

- 96、==和equals的比较

\==实际上比较的是栈中存放的值，如果是引用类型，比如说对象，那么栈中存放的将是对象在堆中的内存地址，所以\==比较两个对象时由于内存地址不同，所以结果为false。object的equals方法默认也是使用的==比较，因此在使用到对象比较时，我们一般会重写equals方法。比如String类中的equals方法就被JDK重写了，使得比较的是真实的内容（循环比较每个字符），而不是内存地址。

- 97、ArrayList和LinkedList区别？

ArrayList是使用数组进行实现的，而LinkedList是使用链表进行实现的。这两种不同的数据结构实现的集合有着不同的特点：ArrayList由于是数组实现的，内存空间是连续的，因此如果在规定容量下进行下标索引查找或者使用尾插法插入数据的话，效率是十分高的。但是如果需要在数组的中间进行插入操作或者由于大小超出容量需要扩容时，则会有一步数据大量复制的操作，这是十分损耗性能的；LinkedList由于由链表实现，链表的内存空间是不连续的，因此每个节点需要保存前后节点的地址，因此查找十分的损耗性能，所以在平时使用时一般不会使用for进行元素的遍历，因为每次的get(i)都是一次查找，而是使用foreach进行iterator的迭代遍历。但是插入和删除由于只要找到相应的节点位置，更改节点间的引用即可，因此效率非常高。总结，ArrayList适合确定容量且查询操作十分频繁的数据存储，而LinkedList适合大数据量以及需要频繁增添修改的数据存储。

- 98、java面向对象有哪些特征？

所谓面向对象，主要是指封装、继承和多态。三者是层层递进的。时间万物皆有其规律和特征，我们将相同的一类规律封装成一个对象，规律对于某个具体的一类对象可能稍有偏差，因此我们可以在原先规律的基础上再封装成一个新的对象，此为继承。然而当我们在某个衍生的规律中调用原先的规律表示时，实际上是调用的是衍生的规律，此为多态。封装继承主要体现在程序的复用性和可维护性，而多态则更多的体现了程序的灵活性以及可移植性。

- 99、list和set的区别

    list是有序的，且可以重复。存储的值中可以有多个null值。而set是无序的，数据不能重复，存储的值中最多有一个null值，且需要使用iterator进行遍历，之所以不能重复是由于底层使用的是hashMap。

- 100、java8的新特性。

java8新增了lambda表达式的操作，通过lambda表达式还衍生出了函数式接口的特殊接口，主要由消费型，供给型，断言型，转换型四种，以及用于处理空对象的Optional接口和用于对象比较的Comparator接口。并且为了适应lambda技术，现在的接口中可以有默认和静态方法实现了。因为lambda技术的出现，还诞生出了一些基于lambda的新技术，例如专用于collections集合对象处理的Stream流操作等。

- 101、抽象类和接口的区别

抽象类是一种对于主观事物概念的描述。语义上：1、抽象类中可以定义成员变量，2、一个类只能继承一个抽象类，3、抽象类中可以有抽象方法和具体实现，4、抽象类中的抽象方法必须是公有的，5、抽象类中可以自定义构造器，6、抽象类中可以有静态方法，7、抽象类可以没有抽象方法。

接口是对某些事物共有的特性、能力的一种抽象描述。语义上：1、接口中不能自定义构造器，2、在jdk1.7以前，方法只能是抽象方法，1.8后为了适应lambda技术方法中可以包含默认方法和静态方法实现，3、抽象类中的成员可以是private、默认、protected、public，4、接口中定义的接口成员变量实际上都是常量，5、一个类可以实现多个接口。

- 102、说说redis事务？

一般事务有着ACID原则，即原子性、一致性、隔离性和持久性。而Radis由于事务是通过multi开启，再然后通过exec串行执行，不存在多会话同时访问的情况，因此不存在隔离性。而后，只要radis的语法正确，就算实际执行事务的过程中出错，也仅仅只是跳过此次错误继续执行，因此radis不保证事务的的原子性。可以使用乐观锁在执行事务前对要操作的数据进行watch加锁从而保证事务操作的原子性，一旦数据被其他redis操作则会直导致事务执行失败。事务执行之后不管是否执行成功还好是失败，都会取消对应的监视，使用unwatch会手动取消所有的key监视，慎用。

- 103、spring的BeanFactory和ApplicationContext的区别，参考[链接](https://blog.csdn.net/pythias_/article/details/82752881)。

BeanFactory是spring最底层的接口，提供最简单的容器的功能，只提供了实例化对象和拿对象的功能。BeanFactory在启动的时候不会去实例化bean，而是等到程序从容器中拿bean时才会去实例化。

ApplicationContext继承自BeanFactory，提供了更加强大的容器功能，如国际化，ResourceLoader访问资源，消息发送响应机制(ApplicationEventPublisher)，AOP（切面拦截器），以及载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层 。

BeanFactory：应用启动的时候占用资源很少；对资源要求较高的应用，比较有优势，适合单元测试使用。

ApplicationContext：1. 所有的Bean在启动的时候都加载，系统运行的速度快；2. 在启动的时候所有的Bean都加载了，我们就能在系统启动的时候，尽早的发现系统中的配置问题；3. 建议web应用使用，在启动的时候就把所有的Bean都加载了。（把费时的操作放到系统启动中完成） 

- 104、HashMap和HashTable的区别是什么？

HashTable是早于HashMap出现的，它是默认线程安全的（synchronized修饰）。由于开发者发现平时开发中使用较少，因此在此基础上开发出了HashMap，是非线程安全的，效率比HashTable的效率高很多。他们之间的差别一般而言有以下几点：1、HashTable默认是线程同步的，HashMap是非线程同步的。2、HashTable是不允许<K,V>为null值的，而HashMap是允许存在一个Key为null值，多个Value为null值的。3、HashMap与HashTable的继承类不同，因此HashTable使用Enumeration进行遍历操作，而HashMap则是使用的iterator进行遍历操作。4、HashTable的默认大小是11，扩容操作是n*2+1，而HashMap的默认大小是16，并且有默认的负载因子0.75，一旦数据容量超过负载因子与容量的乘积数，则会以2的指数倍进行扩容。

- 105、HashMap怎么实现线程安全？

第一种方法：可以使用Collections.synchronizedMap()方法对需要保证线程安全的HashMap进行包裹，会处理返回一个新的HashMap对象，主要是使用了synchronized修饰符保证线程安全，并使用了代理模式返回一个基于HashMap之上的Map线程安全类。代码实现较为简单，但效率不高，因为synchronized锁的是对象。

第二种方式，使用HashMap的线程安全版：ConcurrentHashMap，它的是基于CAS算法从而保证线程安全的，代码实现比较复杂。

- 106、MVCC实现原理

MVCC的实现原理主要是依据于三个隐藏字段，undolog，read view来实现的。

隐藏字段分别是DB_TRX_ID(最近修改事务ID)，DB_ROLL_PTR(回滚指针)以及DB_ROLL_ID(隐藏额的主键)。

undolog主要是使用链表的方式将各个事务以事务Id的方式相互连接形成一个事务日志。

Read View有三个全局属性：trx_list:用于记录维护系统正活跃的事务ID，up_limit_id:用于记录最小的活跃事务ID，low_limit_id，Read View（快照读）生成时系统尚未分配的下一个事务ID；Read View根据这些属性与DB_TRX_ID进行比较，从而判断能不能从undolog中读取提交数据。但是不同的隔离级别下Read View的生成时机是不同的，因此可读取的数据也是不同的。在RC隔离级别下，每个快照读都会生成获取最新的Read View，而在RR隔离级别下，同一个事务中只有第一个快照读会创建Read View，之后的快照读获取的都是同一个Read View。

- 107、Mybatis的优缺点

优点：1、简单门槛低；2、数据库兼容很好，支持绝大多数的主流数据库；3、自动封装JDBC代码，书写简单；4、提供XML文件书写更加复杂的动态SQL语句；5、支持众多插件，分页插件/逆向插件；6、支持对象关系映射，resultmap和association。

缺点：1、业务复杂的话，需要手动书写兼顾性能的复杂SQL，SQL能力要求比较高；2、由于各个数据库的SQL高级语法的不同，因此可移植性较差。

- 108、hibernate和mybatis区别

1、hibernate是全自动的，bean对象和数据库字段之间有着完整的关系映射，因此SQL对于程序员而说是黑盒状态，如果出现SQL错误将很难排查。mybatis是半自动的，需要使用注解或者XML文件来手动编写SQL，SQL是白盒状态，因此排查SQL错误会相对简单。

2、hibernate由于基本上不需要写SQL语句，直接调用底层封装的方法实现SQL查询，因此兼容性已经在底层实现，移植性很好。而mybatis由于需要手动书写SQL，由于数据库之间的高级语法的不同，因此可移植性较差。

3、hibernate的日志系统比之mysql的更加完善。

4、Mybatis比之hibernate更加注重于业务的细节，能够实现更加复杂的业务操作。

5、mybatis的SQL优化要比hibernate容易方便的多。

6、缓存上，hibernate的缓存机制要优于mybatis，这是因为mybatis一般需要手动对具体的表(namespace)进行缓存的配置，从而可以在相同的namespace中共享相同的缓存配置和实例；hibernate是有完善的缓存管理机制的，一旦使用二级缓存时出现脏读，则系统会进行报错消息提示。

总结六方面：自动化，可移植性，日志管理，sql优化，缓存机制，业务专注

- 109、mybatis中的#{}和${}

#{}是预编译的，会预编译成?，再然后通过preparedstatement进行set设置；${}本质就是字符串替换，因此可能会产生sql注入问题。如果进行模糊查询的话，一般会使用concat("%",#{查询字段},"%")进行字符串拼接查找。

- 110、mysql的复制原理是什么？

一般而言，涉及到mysql复制指的都是多机部署实现主从复制。主要经过以下环节：1、主机master在进行数据写入操作前会将操作记录也写入binlog二进制日志文件，2、slave从机服务器会在一定的之间间隔内监听master的二进制日志文件是否改变，如果监听到文件改变，则会开启一个I/O线程用于请求master上的binlog日志文件，3、此时master会为每一个请求的I/O线程都启动一个dump线程，用于向其发送二进制文件，slave会将binlog日志存储到中继日志（relaylog）中，这是因为需要使用顺序读写来快速传输二进制文件，4、最后，slave观察到中继日志文件改变，因此创建了一个SQL线程通过随机读写的方式从中继日志中获得binlog日志内容，将数据写入到slave数据库，完成读写分离，数据同步。在此过程中，需要注意主从节点间的时间需要做同步处理，其次保证主从节点的mysql数据库版本最好一致，如果不能保证一致，则主节点的版本需要低于从节点。

- 111、mysql的聚簇索引和非聚簇索引区别？

首先，我们知道，索引是存储在硬盘中进行持久化的，因此索引的类型和存储引擎的类型是息息相关的。一般而言，从文件结构上区分，聚簇索引是指一张表的索引和数据都放在同一个文件中，而非聚簇索引一般会将索引和数据分成两个文件进行存储。例如innodb就是使用的.idb后缀文件来集中存储聚簇索引的。但如果说一张表有多个索引，那么除了主索引是和数据绑定的聚簇索引外，其余索引存储的都是聚簇索引的key值，因此innodb同时包含聚簇索引和非聚簇索引。聚簇索引会比非聚簇索引检索数据的速度更快，但同样和数据的耦合性也更高。

- 112、mysql索引的基本原理

索引是为了提高数据库数据查询速度的一种数据结构，mysql中提供了两种数据结构，分别是Hash和B+tree，这两种方式各有优劣。其中hash索引是将数据进行hash计算后的key值和data值存储到hash表中，并使用hash桶来解决hash冲突的问题，在等值查询时的速度非常快，然而不支持范围区间查询，而且如果出现大量hash冲突的话需要进行进一步的比对操作，此时的效率并不比B+tree高；B+tree是基于Btree实现的，它是一个平衡查找多叉树，除了底层会存储真正的数据外，其他层存储的都是下一层page的索引，因此会进行多次I/O读取操作，查询效率比之hash索引较慢，但随着层数的增加，其索引的数据也是呈指数级增长的，因此检索的效率比较平均，不向BTree波动那样大，并且支持区间范围查询。

- 113、Cors跨域问题怎么解决？

Cors是浏览器端保证数据安全的一种策略，它要求两个相互请求的资源路径的域名和端口号都必须相同，否则就会出现跨域问题。因此，如果在前后端分离开发联调时是需要做跨域处理的。解决方案有两种：1、服务器端后端进行跨域处理，这种方式较为简单，可以使用Springboot中的注解实现，也可以使用WebConfig子类实现，还可以写一个过滤器来实现。2、前端自己处理，由于CROS是浏览器之间的策略，因此，可以使用node启动前端项目时的服务器作为代理服务器与真正的后端服务器进行请求发送。

- 114、mysql的锁有哪些？

属性分类：共享锁、排它锁。即读锁和写锁的区别。

粒度分类：行锁，间隙锁，页锁，表锁，记录锁，临键锁。

- 115、Mysql为什么要进行主从同步？

1、如果主库在进行锁表写入时需要保证有一个从库给其他业务进行读取操作。

2、一般会将一个从机设置为热备，在平时不参与业务数据读写，只进行主从复制，这样在主机发生意外宕机后从机会接替主机，从而保证正常的业务供应。

3、当存储的数据量很大时，可以部署多个从库用于数据读取，这样能够减少单台服务器的I/O压力，提高查询效率。

- 116、mysql的执行计划怎么看？

    > 详细[链接](https://www.cnblogs.com/wd326150354/p/11022093.html)

通常，当我们需要细致得优化MySQL的执行效率的时候，我们一般会使用desc或explain命令来查看mysql的执行计划。执行计划主要是观察以下几个方面：1、id：id是select查询的序列号，表示查询过程中执行select子句或者操作表的顺序。如果id相同，那么执行顺序从上到下；如果id不同，id的序号会递增，越大的越先被执行。2、select_type：就是select类型，主要用于区别普通查询, 联合查询, 子查询等复杂查询。3、type：表示MySQL在表中找到所需行的方式，又称“访问类型”（ALL、index、range、ref、eq_ref、const、system、NULL），由左至右，由最差到最好。4、possible_keys：指出MySQL能使用哪个索引在表中找到行，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。5、key：显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL。6、key_len：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。7、ref：表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值。8、rows：表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数。9、Extra：包含不适合在其他列中显示但十分重要的额外信息。

